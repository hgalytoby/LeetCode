Given a binary string  `s`  and an integer  `k`, return  `true`  _if every binary code of length_  `k`  _is a substring of_  `s`. Otherwise, return  `false`.

**Example 1:**
```
Input: s = "00110110", k = 2
Output: true
Explanation: The binary codes of length 2 are "00", "01", "10" and "11". They can be all found as substrings at indices 0, 1, 3 and 2 respectively.
```

**Example 2:**
```
Input: s = "0110", k = 1
Output: true
Explanation: The binary codes of length 1 are "0" and "1", it is clear that both exist as a substring. 
```

**Example 3:**
```
Input: s = "0110", k = 2
Output: false
Explanation: The binary code "00" is of length 2 and does not exist in the array.
```

**Constraints:**

-   `1 <= s.length <= 5 * 105`
-   `s[i]`  is either  `'0'`  or  `'1'`.
-   `1 <= k <= 20`


### Python
```py
MAPPING = {i: {"".join(x) for x in product("01", repeat=i)} for i in range(1, 21)}


class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        n = len(s)
        visited = set()
        target = MAPPING[k]
        for i in range(n - k + 1):
            v = s[i : i + k]
            visited.add(v)
            if visited == target:
                return True
        return False
```

```python
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        target = 1 << k
        result = set()
        for i in range(0, len(s) - k + 1):
            result.add(s[i:i + k])
        return len(result) == target
```


```python
class Solution:
    def hasAllCodes(self, s: str, k: int) -> bool:
        target = 1 << k
        result = set()
        for i in range(0, len(s) - k + 1):
            temp = s[i:i + k]
            if temp not in result:
                result.add(temp)
                target -= 1
                if target == 0:
                    return True
        return False
```